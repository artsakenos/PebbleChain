/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package tk.artsakenos.pebblechain._Samples;

import tk.artsakenos.iperunits.file.SuperFileText;

/**
 *
 * @author Andrea
 */
public class UltraFFMpeg {

    private static String line0 = "";
    private static String line1 = "";
    private static String line2 = "";

    public static void subs(String text) {
        SuperFileText.setText("subtitles.srt", "");
        // String[] lines = text.replaceAll("\r", "").split("\n");
        for (int i = 0; i < text.length() / 80 - 2; i++) {
            // for (int i = 0; i < lines.length - 2; i++) {
            line0 = line1;
            line1 = line2;
            if (text.length() / 80 - 2 < i) {
                return;
            }
            line2 = text.substring(i * 80, i * 80 + 80);
            SuperFileText.append("subtitles.srt", i + 1 + "\n");
            SuperFileText.append("subtitles.srt", getTime(i) + "\n");
            SuperFileText.append("subtitles.srt", line0 + "\n");
            SuperFileText.append("subtitles.srt", line1 + "\n");
            SuperFileText.append("subtitles.srt", line2 + "\n");
            SuperFileText.append("subtitles.srt", "\n");
        }
    }

    private static String getTime(int i) {
        int mil = i % 2 * 5;
        int sec = i / 2 % 60;
        int min = i / 2 / 60;
        String time = "00:" + min + ":" + sec + "," + mil + "00 --> 00:" + min + ":" + sec + "," + (mil + 4) + "00";
        return time;
    }

    public static void main(String[] args) {
        subs("{\n"
                + "  \"hash_previous\" : \"caffe58c4e0e81f1b90d40dc74e186be6744f2009eb12fbb0daddaa0863e459b\",\n"
                + "  \"links_previous\" : [ \"https://pastebin.com/mUiUB2dL\", \"https://docs.google.com/document/d/12vLMWE1PlJQiEpYz599o6OqZ4NCOO12isqGvlBtUu00\" ],\n"
                + "  \"target\" : \"caffe\",\n"
                + "  \"version\" : 191105,\n"
                + "  \"owner\" : \"andrea\",\n"
                + "  \"data\" : \"/*\\r\\n * To change this license header, choose License Headers in Project Properties.\\r\\n * To change this template file, choose Tools | Templates\\r\\n * and open the template in the editor.\\r\\n */\\r\\npackage tk.artsakenos.pebblechain;\\r\\n\\r\\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\\r\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\r\\nimport com.fasterxml.jackson.core.JsonProcessingException;\\r\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\r\\nimport java.io.IOException;\\r\\nimport java.io.Serializable;\\r\\nimport static java.nio.charset.StandardCharsets.UTF_8;\\r\\nimport java.security.MessageDigest;\\r\\nimport java.security.NoSuchAlgorithmException;\\r\\nimport java.text.NumberFormat;\\r\\nimport java.time.Instant;\\r\\nimport java.util.Calendar;\\r\\nimport java.util.Locale;\\r\\nimport java.util.logging.Level;\\r\\nimport java.util.logging.Logger;\\r\\n\\r\\n/**\\r\\n * First case study of a \\\"social repositories\\\" based chain. A pebble of the\\r\\n * PebbleChain.\\r\\n *\\r\\n * @author Andrea\\r\\n */\\r\\n@JsonIgnoreProperties(ignoreUnknown = true)\\r\\npublic class Pebble implements Serializable {\\r\\n\\r\\n    public static final String P_ALGORITHM = \\\"SHA-256\\\";\\r\\n    public static final String P_HASHSTART = \\\"ðŸ’ŽTHROWN#GENESIS\\\";\\r\\n    public static final String[] P_LINKSTART = new String[]{};\\r\\n    public static final int P_PREFIX_MINLENGTH = 4;\\r\\n    public static final int P_DATA_MAXSIZE = 10 * 1024 * 1024;\\r\\n\\r\\n    public static final int VERSION_20191105 = 191105;\\r\\n\\r\\n    private String hash_previous = P_HASHSTART;\\r\\n    private String[] links_previous = P_LINKSTART;\\r\\n    private String target = \\\"0000\\\";\\r\\n    private int version = VERSION_20191105;\\r\\n    private int depth = -1;\\r\\n    private boolean verbose = true;\\r\\n\\r\\n    private String owner; // Switch to OpenId, plus PGP.\\r\\n    private String data;\\r\\n    private long created_epoch;\\r\\n    private String hash_current;\\r\\n    private String merkel_root;\\r\\n    private int nonce = 0;\\r\\n\\r\\n    // -------------------------------------------------------------------------\\r\\n    public Pebble() {\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Creates a new Pebble.\\r\\n     *\\r\\n     * @param owner\\r\\n     * @param data\\r\\n     * @throws PebbleException\\r\\n     */\\r\\n    public Pebble(String owner, String data) throws PebbleException {\\r\\n        this(P_HASHSTART, P_LINKSTART, \\\"0000\\\", owner, data, null, Calendar.getInstance(Locale.getDefault()).getTimeInMillis(), VERSION_20191105, 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Loads an existing Peeble\\r\\n     *\\r\\n     * @param hash_previous The Hash of the previous Pebble in the Chain\\r\\n     * @param link_previous The link URI where to find the previous Pebble\\r\\n     * @param prefix The chosen target. Lower cased hex. Its length must be >\\r\\n     * P_PREFIX_MINLENGTH, and will be a proof of work giving a value to the\\r\\n     * Peeble according to the target length and nonce value.\\r\\n     * @param data The data of the Pebble.\\r\\n     * @param hash_current The hash\\r\\n     * @param created_epoch The epoch\\r\\n     * @param nonce The nonce\\r\\n     */\\r\\n    public Pebble(String hash_previous, String[] links_previous, String prefix, String owner, String data,\\r\\n            String hash_current, long created_epoch, int version, int nonce) throws PebbleException {\\r\\n        if (!prefix.matches(\\\"-?[0-9a-f]+\\\")) {\\r\\n            throw new PebbleException(PebbleException.ET_INVALID_HEX, prefix + \\\" is not exadecimal.\\\");\\r\\n        }\\r\\n        this.created_epoch = created_epoch;\\r\\n        this.hash_previous = hash_previous;\\r\\n        this.links_previous = links_previous;\\r\\n        this.data = data;\\r\\n        this.target = prefix;\\r\\n        this.hash_current = hash_current;\\r\\n        this.nonce = nonce;\\r\\n        this.version = version;\\r\\n        this.owner = owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * The Header is a 264 bit string used to sign the block\\r\\n     *\\r\\n     * @return the block header\\r\\n     */\\r\\n    private String retrieveHeader() {\\r\\n        return getMerkel_root() + getCreated_epoch() + getNonce();\\r\\n    }\\r\\n\\r\\n    public void mineBlock() {\\r\\n        this.merkel_root = retrieveMerkelRoot(this, getVersion());\\r\\n        this.setCreated_epoch(Calendar.getInstance().getTimeInMillis());\\r\\n        String hash = \\\"\\\";\\r\\n        while (!hash.startsWith(target)) {\\r\\n            ++nonce;\\r\\n            hash = computeHash(P_ALGORITHM, retrieveHeader());\\r\\n            if (verbose) {\\r\\n                verboseMining();\\r\\n            }\\r\\n            // Updates timestamp time to time\\r\\n            if (nonce % 1_000_000 == 0) {\\r\\n                this.setCreated_epoch(Calendar.getInstance().getTimeInMillis());\\r\\n            }\\r\\n        }\\r\\n        setHash_current(hash);\\r\\n    }\\r\\n\\r\\n    private void verboseMining() {\\r\\n        if (getNonce() % 10_000 == 0) {\\r\\n            System.out.print(\\\".\\\");\\r\\n        }\\r\\n        if (getNonce() % 1_000_000 == 0) {\\r\\n            String nf = NumberFormat.getNumberInstance(Locale.US).format(getNonce());\\r\\n            // Gives an idea of how much of the integer (half) spectrum has passed\\r\\n            double percentage = (double) getNonce() / (double) Integer.MAX_VALUE * 100.0;\\r\\n            System.out.println(String.format(\\\" %s; %,.2f%%\\\", nf, percentage));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Check given rules.\\r\\n     *\\r\\n     * @return true if the Pebble is considered valid (rules can vary according\\r\\n     * to the version).\\r\\n     */\\r\\n    public boolean isValid() {\\r\\n        this.merkel_root = retrieveMerkelRoot(this, getVersion());\\r\\n        String hash = computeHash(P_ALGORITHM, retrieveHeader());\\r\\n        String message = \\\"\\\";\\r\\n\\r\\n        if (!hash.equals(hash_current)) {\\r\\n            message += \\\"Hash Signature doesn't match; \\\";\\r\\n        }\\r\\n\\r\\n        // Check Prefix Length\\r\\n        if (getTarget().length() < P_PREFIX_MINLENGTH) {\\r\\n            message += \\\"Short Prefix \\\" + getTarget().length() + \\\"<\\\" + P_PREFIX_MINLENGTH + \\\"; \\\";\\r\\n        }\\r\\n\\r\\n        // Check Previous Links\\r\\n        if (getLinks_previous() == null) {\\r\\n            message += \\\"Previous_link can't be null, can be empty though; \\\";\\r\\n        }\\r\\n\\r\\n        // Check Data Length, 10MB maximum right now.\\r\\n        if (getData().length() > P_DATA_MAXSIZE) {\\r\\n            message += \\\"Data packet too big, >\\\" + P_DATA_MAXSIZE + \\\"; \\\";\\r\\n        }\\r\\n\\r\\n        if (message.isEmpty()) {\\r\\n            return true;\\r\\n        } else {\\r\\n            Logger.getLogger(Pebble.class.getName()).log(Level.WARNING, message.trim());\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    @Override\\r\\n    public String toString() {\\r\\n        return getId() + \\\", \\\" + getNonce();\\r\\n    }\\r\\n\\r\\n    public static String toJson(Pebble pebble) {\\r\\n        ObjectMapper mapper = new ObjectMapper();\\r\\n        try {\\r\\n            mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\\r\\n            return mapper.writerWithDefaultPrettyPrinter().writeValueAsString(pebble);\\r\\n        } catch (JsonProcessingException ex) {\\r\\n            Logger.getLogger(Pebble.class.getName()).log(Level.SEVERE, null, ex);\\r\\n        }\\r\\n        return null;\\r\\n    }\\r\\n\\r\\n    public static Pebble fromJson(String json) {\\r\\n        ObjectMapper mapper = new ObjectMapper();\\r\\n        try {\\r\\n            Pebble pebble = mapper.readValue(json, Pebble.class);\\r\\n            return pebble;\\r\\n        } catch (IOException ex) {\\r\\n            Logger.getLogger(Pebble.class.getName()).log(Level.SEVERE, null, ex);\\r\\n        }\\r\\n        return null;\\r\\n    }\\r\\n\\r\\n    // -------------------------------------------------------------------------\\r\\n    /**\\r\\n     * Compute Hash of the Data according to the seleced Algorithm, e.g.,\\r\\n     * SHA256.\\r\\n     *\\r\\n     * @param dataToHash\\r\\n     * @return Hash of the data\\r\\n     */\\r\\n    public final String computeHash(String algorithm, String dataToHash) {\\r\\n        MessageDigest digest;\\r\\n        byte[] bytes;\\r\\n        try {\\r\\n            digest = MessageDigest.getInstance(algorithm);\\r\\n        } catch (NoSuchAlgorithmException ex) {\\r\\n            Logger.getLogger(Pebble.class.getName()).log(Level.SEVERE, null, ex);\\r\\n            return null;\\r\\n        }\\r\\n        bytes = digest.digest(dataToHash.getBytes(UTF_8));\\r\\n        StringBuilder buffer = new StringBuilder();\\r\\n        for (byte b : bytes) {\\r\\n            buffer.append(String.format(\\\"%02x\\\", b));\\r\\n        }\\r\\n        return buffer.toString();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Retrieve the Merkel Root Hash to build the header, according to the\\r\\n     * pebble version.\\r\\n     *\\r\\n     * @param pebble A pabble.\\r\\n     * @param version The version.\\r\\n     * @return The merkel root.\\r\\n     */\\r\\n    public String retrieveMerkelRoot(Pebble pebble, int version) {\\r\\n        String merkel_data = null;\\r\\n\\r\\n        if (version == VERSION_20191105) {\\r\\n            String links = \\\"\\\";\\r\\n            for (String link : pebble.getLinks_previous()) {\\r\\n                links += link + \\\"\\\\n\\\";\\r\\n            }\\r\\n            merkel_data = version + \\\"\\\\n\\\"\\r\\n                    + pebble.getHash_previous() + \\\"\\\\n\\\"\\r\\n                    /**\\r\\n                     * The target is included to be \\\"declared\\\" before mining.\\r\\n                     */\\r\\n                    + pebble.getTarget() + \\\"\\\\n\\\"\\r\\n                    + pebble.getOwner() + \\\"\\\\n\\\"\\r\\n                    + links\\r\\n                    /**\\r\\n                     * In other version could be a transaction encrypted with\\r\\n                     * the owner private key.\\r\\n                     */\\r\\n                    + pebble.getData() + \\\"\\\\n\\\";\\r\\n        }\\r\\n        return computeHash(P_ALGORITHM, merkel_data);\\r\\n    }\\r\\n\\r\\n    // -------------------------------------------------------------------------\\r\\n    /**\\r\\n     * @return the hash_current\\r\\n     */\\r\\n    public String getHash_current() {\\r\\n        return hash_current;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the hash_current\\r\\n     */\\r\\n    public String getHash_previous() {\\r\\n        return hash_previous;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the created_epoch\\r\\n     */\\r\\n    public long getCreated_epoch() {\\r\\n        return created_epoch;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the link_previous\\r\\n     */\\r\\n    public String[] getLinks_previous() {\\r\\n        return links_previous;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the mining target\\r\\n     */\\r\\n    public String getTarget() {\\r\\n        return target;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the nonce\\r\\n     */\\r\\n    public int getNonce() {\\r\\n        return nonce;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the data. In a secret transaction data could be encrypted\\r\\n     * according to the recipient private key.\\r\\n     */\\r\\n    public String getData() {\\r\\n        return data;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * The value of the Pebble. The price is calculated according to some\\r\\n     * variables which more or less represent the calculation time.\\r\\n     *\\r\\n     * @return\\r\\n     */\\r\\n    public double getValue() {\\r\\n        return Math.pow(10, getTarget().length() - 15) * getNonce() * retrieveHeader().length();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns a Pebble Identifier\\r\\n     *\\r\\n     * @return a Pebble identifier\\r\\n     */\\r\\n    public String getId() {\\r\\n        return \\\"ðŸ’Ž\\\" + getTarget() + \\\"#\\\" + getHash_current();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Creation date in IS8601\\r\\n     *\\r\\n     * @return The date created\\r\\n     */\\r\\n    public String getCreatedISO8601() {\\r\\n        return Instant.ofEpochMilli(getCreated_epoch()).toString();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the version\\r\\n     */\\r\\n    public int getVersion() {\\r\\n        return version;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the owner\\r\\n     */\\r\\n    public String getOwner() {\\r\\n        return owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param hash_previous the hash_previous to set\\r\\n     */\\r\\n    public void setHash_previous(String hash_previous) {\\r\\n        this.hash_previous = hash_previous;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param links_previous the links_previous to set\\r\\n     */\\r\\n    public void setLinks_previous(String[] links_previous) {\\r\\n        this.links_previous = links_previous;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param target the target to set\\r\\n     */\\r\\n    public void setTarget(String target) {\\r\\n        this.target = target;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param data the data to set\\r\\n     */\\r\\n    public void setData(String data) {\\r\\n        this.data = data;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param version the version to set\\r\\n     */\\r\\n    public void setVersion(int version) {\\r\\n        this.version = version;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param owner the owner to set\\r\\n     */\\r\\n    public void setOwner(String owner) {\\r\\n        this.owner = owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the depth\\r\\n     */\\r\\n    public Integer getDepth() {\\r\\n        if (depth < 0) {\\r\\n            // Not set.\\r\\n            return null;\\r\\n        }\\r\\n        return depth;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param depth the depth to set\\r\\n     */\\r\\n    public void setDepth(int depth) {\\r\\n        this.depth = depth;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param verbose the verbose to set\\r\\n     */\\r\\n    public void setVerbose(boolean verbose) {\\r\\n        this.verbose = verbose;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param created_epoch the created_epoch to set\\r\\n     */\\r\\n    public void setCreated_epoch(long created_epoch) {\\r\\n        this.created_epoch = created_epoch;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param hash_current the hash_current to set\\r\\n     */\\r\\n    public void setHash_current(String hash_current) {\\r\\n        this.hash_current = hash_current;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the merkel_root\\r\\n     */\\r\\n    public String getMerkel_root() {\\r\\n        return merkel_root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param nonce the nonce to set\\r\\n     */\\r\\n    public void setNonce(int nonce) {\\r\\n        this.nonce = nonce;\\r\\n    }\\r\\n\\r\\n    // -------------------------------------------------------------------------\\r\\n}\\r\\n\",\n"
                + "  \"created_epoch\" : 1573180847331,\n"
                + "  \"hash_current\" : \"caffea20ea147c37d03f158dba072885980afdf711ae877314f5d7effd0d563d\",\n"
                + "  \"merkel_root\" : \"76a314a399534f7b0586dda2e0cf50a6ca82662eca8303cc84e742c8d8d4902c\",\n"
                + "  \"nonce\" : 297288,\n"
                + "  \"value\" : 0.0024674904000000003,\n"
                + "  \"id\" : \"ðŸ’Žcaffe#caffea20ea147c37d03f158dba072885980afdf711ae877314f5d7effd0d563d\",\n"
                + "  \"valid\" : true,\n"
                + "  \"createdISO8601\" : \"2019-11-08T02:40:47.331Z\"\n"
                + "}");
    }
}
